ift1020-98A, TP1: Dictionnaires (en arbre)
===========================================
version 1.2 (2 oct 1998)

Echeance(modifiee):  A rendre avant lundi le 19 octobre 1998 a midi.

But: Ce tp vise a vous familiariser avec la manipulation des pointeurs,
     la conception des programmes recursifs, et les operations sur les
     listes et les arbres binaires.

1. Arbre de la Briandais
-------------------------
L'arbre "de la Briandais" est un arbre binaire particulier, utilise pour
stocker les dictionnaires (du francais, par exemple). Dans cet arbre, chaque
noeud contient une lettre, deux pointeurs, et eventuellement d'autres
informations. Le premier pointeur sert a indiquer la prochaine lettre dans le
mot. Le second indique les alternatives. Voici un exemple (ou --> indique la
prochaine lettre, "|" une alternative, et * indique la fin d'un mot):

    B --> A --> S* --> E*
    |
    L --> I --> S --> T --> E*
    |           |
    |           V --> R --> E*
    |
    T --> A --> B --> A --> C*
                |
                S*
                  
Cet arbre stocke les mots: BAS, BASE, LISTE, LIVRE, TABAC et TAS.
  
On peut aussi voir un tel arbre comme etant organise en differents niveaux: le
premier niveau correspond aux premieres lettres des mots, le deuxieme niveau
aux deuxiemes lettres, etc. Les noeuds d'un meme niveau constituent une liste
triee.

L'avantage de cette organisation par rapport a une simple liste de mots est
evident: elle economise l'espace, le temps pour trouver un mot est plus court.
Theoriquement, l'emploi d'un arbre devrait donner des dictionnaires

Certains noeuds (marques par * dans la figure) dans l'arbre sont des noeuds
terminaux, c'est-a-dire qu'ils contiennent la derniere lettre d'un mot. Dans un
vrai dictionnaire, les noeuds terminaux contiendraient d'autres informations
sur le mot telles que la categorie grammaticale (nom, verbe, etc), le genre, le
nombre, la definition ou la traduction, etc...

2. Le tp
---------
Ce tp consiste a realiser deux dictionnaires.  Le premier sera base sur
sur les arbres de la Briandais.  Le second utilisera la classe Vector, 
pre-definie dans Java. Le premier devrait etre rapide mais complexe a coder
tandis que le deuxieme devrait etre trivial a coder mais beaucoup plus lent.
Pour simplifier le probleme, on suppose que les MOTS et les INFORMATIONS sont
tous deux des MOTS (suite de caracteres non-blancs).

Les operations que vous devez realiser sont les suivantes:

    - Ajouter un mot.
    - Chercher un mot. 
    - Enlever un mot.
    - Imprimer sur l'ecran la liste des mots (et les informations) triee en 
         ordre alphabetique.
	      
Les trois premieres operations doivent donner un avertissement en cas de 
situation anormale.  Vous devez vous conformer aux declarations suivantes:

 abstract class Dictionnaire {
 abstract String chercher( String  m) ;  
 	  // retourne l'INFORMATION associee a "m"
	     //     ou NULL si non trouve
	     abstract boolean ajouter(String m, String info);
	     	      // retourne FALSE si le mot "m" est deja dans le dictionnaire
		      	 //     TRUE autrement
			 abstract boolean enlever(String m);
			 	  // retourne FALSE si le mot "m" n'est pas dans le dictionnaire
				     //     TRUE autrement
				     abstract void imprimer();
 }
  
   class Briandais extends Dictionnaire{...}
   class Vecteur   extends Dictionnaire{...}

Vous etes libre de choisir la structure que vous voulez pour les Noeud des
arbres de La Briandais..... mais ceux-ci auront probablement les champs
suivants:

    class Noeud 
    { char lettre;
      Noeud suite, altern;
      String mot, info;
    }

2. Programme principal
-----------------------

On vous demande de soumettre un fichier nomme "tp1.java" contenant vos classes.
Nous utiliserons notre propre programme principal pour tester vos classes.  

Pour tester vos classes vous devrez implanter vos propres classes de test avec
des programmes principaux (main). Des fichiers que nous utiliserons pour tester 
vos programmes seront mis  dans ~dift1020/pub/TP1.  Ce sont des fichiers de 
commandes dans le format suivant:

	  c <mot>
	  a <mot> <information>
	  e <mot>
	  i
	  
Chaque commande tiend sur une seule ligne et c'est la premiere lettre qui
indique l'operation a effectuer: i(mprimer), a(jouter), e(nlever), c(hercher).
Chaque commande tiend sur une seule ligne et les differents elements d'une
commande sont separes par des blancs.  Le champ <information> est d'une
longueur maximum de 20 caracteres.

	 dat1 :	 petit fichier test
	 dat2 :    gros fichier test 
	           - ajout de 1000+ mots et retrait des memes mots


3. Criteres d'evaluation
--------------------------

Ce tp compte pour 10% (10 points) dans la note finale, repartis comme suit:
   - le programme: 7 points, ( fonctionnement, style et l'organisation
         globale).
	 - le rapport:   3 points.

Remise du programme:  LUNDI le 19 octobre 1998 a midi
Remise du rapport:    LUNDI le 19 octobre 1998 a 14h30 au debut du cours

Vous devez remettre le programme avant l'heure limite. Apres l'heure, il y a 1
point de penalite pour chaque jour de retard. 

Vous pouvez le faire seul ou en groupes de 2 personnes.

A part le programme, vous devez aussi remettre en meme temps un mini RAPPORT
(environ 2-3 pages imprimees) qui compare la performance de vos 2
dictionnaires. Des graphiques sont tout indiques, p.e.: temps d'execution
versus Nombre de mots

La fonctionalite de pouvoir enlever un element comptera pour 1 point sur 10. 
Si vous n'arriez pas a l'implanter, ce ne sera pas la catastrophe.
   
Jean Vaucher, 21 sept 1998

===============================================================================

1020 - H96

Ch.5:   Traitement d'arbres
============================

IFT1020 - sept. 1998

ARBRE - Definition:   
-------------------
    Un ARBRE est une structure de donnee qui est 
    
        1) soit vide ou 
        2) composee d'un noeud connecte a un certain nombre (possiblement 
           zero) de structures disjointes qui sont qui sont elles-meme des 
           arbres.
           
Traditionellement en informatique, on represente les arbres 'a l'envers', et
la relation entre un noeud et la racine d'un sous-arbre associe et indique par
un ARC, pe:
 
                  A
                 /|\
                / | \
               B  C  D
                 /  / \
                /  E   F
               G       |
                       J

    Ici, on dira que:   A est la RACINE de l'arbre
                        C, D et F sont des NOEUDS interne
                        B, G, E, J sont des FEUILLES

Les noeuds dans un sous-arbre d'un noeud N sont appeles les descendants de N. 
On dira aussi qu'un noeud est le PARENT des noeuds qui sont immediatement en
dessous de lui (ses ENFANTS).

En general, a chaque noeud, on associe une ETIQUETTE qui sert a l'identifier
et a l'afficher. Il peut aussi y avoir de l'information additionelle.

Les arbres qui nous interessent sont dits "orientes" dans le sens que la
positions des descendants directs est importantes, cad que les 2 arbres
ci-dessous sont differents:

           A          A
          / \        / \
         C   D      D   C
    
Propriete:  Chaque noeud a un seul parent

- ARITE d'un arbre est le nombre maximum d'enfants qu'un noeud peut avoir

- Dans un arbre BINAIRE chaque noeud a un maximum de 2 enfants et on parlera
  de l'enfant/sous-arbre a GAUCHE et de celui a DROITE.
    
- HAUTEUR d'un arbre est le nombre maximum de noeuds entre la racine et 
      les feuilles (l'arbre ci-dessus a une hauteur de 4).
      
- Un arbre binaire de hauteur H peut contenir au maximum (2^H - 1) noeuds:
  p.e. un arbre de hauteur 2 a 3 noeuds.  Inversement, N noeuds peuvent etre   
  stockes dans un arbre de hauteur  CEIL( log2(N) ).  Ceci menera a des 
  algorithmes de recherche de complexite O( log N).
  
ORDRE:  
    Il est habituel d'associer une relation d'ordre a la position des elements 
    d'un arbre.  Typiquement, les noeuds d'un sous-arbre a gauche seront 
    consideres plus petits (<) que ceux de l'arbre a droite. On distingue 
    ensuite 3 types d'arbre selon la relation qui existe entre la valeur d'un 
    NOEUD (N) et celles dans l'arbre a sa gauche (G) et celles dans l'arbre a 
    droite (D). Ceci donne:
    
    PREORDER:       N < G < D
    INORDER:        G < N < D
    POSTORDER:      G < D < N
                                 [ Note: dans chaque cas G < D ] 
  
  
EQUIVALENCE Arbres N'aire et arbre BINAIRE
-------------------------------------------

    TOUT ARBRE peut etre represente par une arbre BINAIRE
    ======================================================
    
Technique:  
    Lier tous les enfants d'un meme parent dans une liste simple (GAUCHE joue   
    le  role de SUIVANT) et le lien DROIT lie un parent a son enfant AINE.
    
Avec cette technique, l'arbre initial devient:

                      Ou si on fait une rotation telle que gauche -> bas
                          et droite va vraimment a droite.
       A              A
      /               |
     B                B--C--D
      \                  |  |
       C                 G  E--F
      / \                      |
     G   D                     J
        /
       E
        \
         F
        /
       J
         
Ceci dit, vous pouvez constater que l'arbre de la Briandais est une version
BINAIRE d'un arbre n'aire ou les enfants indiquent les lettres qui peuvent
suivre le noeud parent.



  Briandais:                   Arbre naire equivalent:
                                            .
   B -- A -- S*-- E*                       /|\  
   |                                      B L T
   L -- I -- S -- T -- E*                /  |  \
   |         |                          A   I   A
   |         V -- R -- E*              /   / \   \
   |                                  S*  S   V   B
   T -- A -- B -- A -- C*            /    |   |   | 
                                    E*    T   R   A
                                          |   |   |
                                          E*  E*  C*

OPERATIONS SUR LES ARBRES
-------------------------

    - parcours ordonne
    - chercher un element
    - ajouter/retrancher un element
    - chercher la taille / la hauteur d'un arbre
    - trouver le Nieme element
    - trouver le predecesseur/successeur d'un noeud

Version 1:   Implantation 'classique"
======================================            

class Node: minimale (sans methodes)  
class Tree: contiend Ref vers le NODE qui est la racine
     et les methodes de manipulation 
							                  - ici ce sont des routines recursives classiques
									                avec le NOEUD courant passe en parametre  

											////////////////////////////////////////////////////////////////
											    class Node
											    ////////////////////////////////////////////////////////////////
											       {
											          public int val, count;          // data item (key)
												     public Node gauche, droite;     // this node's left child
												        
													   Node (int v) {
													             val   = v;
														             count = 1;
															             gauche = droite = null;
																        }
																	   
																	      public String  toString()      // display ourself
																	      // -------------------------------------------------------------
																	         { return "<" + val + ":" + count + ">" ;
																		    }
																		       
																		       }  // end class Node

    
    ////////////////////////////////////////////////////////////////
       class Tree {
       ////////////////////////////////////////////////////////////////
       //	La majorite des methodes sont implantees en 2 temps:
       //      - une methode PUBLIC qui sert d'interface a une autre 
       //            methode qui fait le gros du travail
       //	     	     - la 2ieme methode (privee) est recursive avec un NOEUD  
       //            	     courant passe en parametre
       ////////////////////////////////////////////////////////////////
       
	Node Arbre;
	     
	     //----------------------------------- 
	     					   public void inserer(int n) 
						   //----------------------------------- 
						   					 {	if (Arbre == null)
											 	   	  Arbre = new Node(n);
													  	  else
															  inserer1( n, Arbre );
															  	    }
																     
																        void inserer1(int Cle, Node A) 
																	     		  {    if (Cle == A.val)
																			       	       	  ++ A.count;
																					       else if (Cle < A.val)
																					       	       	      if (A.gauche == null) A.gauche = new Node(Cle);
																							      	 	      	    else
																										         inserer1( Cle , A.gauche);
																											 	       	 else
																													     if (A.droite == null) A.droite = new Node(Cle);
																													     		     	   else
																																        inserer1( Cle , A.droite);
																																		      } 
																																		      	
																																			//----------------------------------- 
																																			    public Node chercher(int cle)      // find node with given key
																																			    //----------------------------------- 
																																			       {				  return cherche1( cle, Arbre);
																																			          }
																																				  
																																				       Node cherche1(int Cle, Node A)  
																																				       	    		    { if ( A == null)
																																							      	     	 return null;
																																									 	      else if ( Cle == A.val ) 
																																										      	               	     return A;
																																													     	          else if ( Cle < A.val ) 
																																															       	     	  	 return cherche1( Cle, A.gauche);
																																																		 		        else   
																																																					               return cherche1( Cle, A.droite);     
																																																						       	      		   }
																																																									   
																																																									   //----------------------------------- 
																																																									   					 public void imprimer()
																																																														 //----------------------------------- 
																																																														 				       { imprimer( Arbre, 0 );
																																																																		       	 	   System.out.println();
																																																																				    }
																																																																				     
																																																																				          void imprimer(Node A, int niv) 
																																																																					          {  if (A == null)
																																																																						               ; //   rien faire
																																																																							       	        else 
																																																																									           { imprimer (A.droite, niv+2);
																																																																										     	         	 
																																																																													       for (int i = 1; i <= 2*niv; i++)
																																																																													       	   	       System.out.print(' ');
																																																																															       			          System.out.println(A);
																																																																																			          imprimer (A.gauche, niv+2);
																																																																																				  	      	        }
																																																																																							    }
																																																																																							     
																																																																																							     }  // end class Tree
																																																																																							     
EXEMPLE D'UTILISATION:
=======================

		public class TreeApp {
		       
				public static void main(String args[]) {
				       	      	   
									Tree A = new Tree();
									       	 
													A.inserer( 30 );
															A.inserer( 50 );
																       A.inserer( 56 );
																       		      A.inserer( 90 );
																		      		     A.inserer( 50 );
																				     		    A.inserer( 45 );
																						    	       	   A.imprimer();
																								      for (int i =1 ; i <= 10; ++i )
																								      	       	    A.inserer( (int) (Math.random() * 10) );
																										    	       	     		    A.imprimer();
																														      }
																														       }


